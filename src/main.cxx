// lascra main file

#include <iostream>
#include <fstream>
#include <string>
#include <argparse/argparse.hpp>
#include <ZipArchive.h>
#include <ZipFile.h>
#include <bparser/node.hxx>
#include <bparser/json.hxx>
#include <bparser/sexpr.hxx>

#include "compiler.hxx"
#include "id.hxx"

int main(int argc, char* argv[]) {
	// Command line parser
	argparse::ArgumentParser lascra("lascra", "0.5");

	std::string sprite3filename;
	lascra.add_argument("sprite")
		.store_into(sprite3filename)
		.required()
		.help("specify sprite file to compile into");

	auto &removalLevel = lascra.add_mutually_exclusive_group();
	bool remove = false;
	removalLevel.add_argument("-r", "--remove")
		.store_into(remove)
		.help("remove existing code");
	bool keep = false;
	removalLevel.add_argument("-k", "--keep")
		.store_into(keep)
		.help("keep all existing code");
	
	bool display = false;
	lascra.add_argument("-d", "--display")
		.store_into(display)
		.help("display generated sprite json");

	std::string spritename;
	lascra.add_argument("-s", "--sprite")
		.store_into(spritename)
		.help("specify which sprite in an sb3 file to use");

	lascra.add_argument("files")
		.remaining()
		.help("specify code files to compile");
	
	try {
		lascra.parse_args(argc, argv);
	}
	catch (const std::exception& err) {
		std::cerr << err.what() << std::endl;
		std::cerr << lascra;
		std::exit(1);
	}

	std::vector<std::string> files;
	try {files = lascra.get<std::vector<std::string>>("files");}
	catch (std::logic_error& e) {}

	bool sb3 = (spritename == "") ? false : true;
	// Open sprite3 file
	ZipArchive::Ptr sprite3;
	{
		std::ifstream* sprite3file = new std::ifstream(sprite3filename, std::ios::binary);
		if (!sprite3file->is_open()) {
			std::cout
				<< "Error: Failed to open " << ((sb3) ? "sb3" : "sprite3") << " file! (\"" << sprite3filename << "\" not found)" << std::endl;
			return EXIT_FAILURE;
		}
		sprite3 = ZipArchive::Create(sprite3file, true);
		if (sprite3 == nullptr) {
			std::cout
				<< "Error: Invalid zip archive (Processing failed)" << std::endl;
			return EXIT_FAILURE;
		}
	}
	// Open sprite.json
	ZipArchiveEntry::Ptr spritejson = (sb3) ? sprite3->GetEntry("project.json") : sprite3->GetEntry("sprite.json");
	if (spritejson == nullptr) {
		std::cout
			<< "Error: Invalid " << ((sb3) ? "sb3": "sprite3") << " file! (Missing " << ((sb3) ? "\"project.json\"" : "\"sprite.json\"") << ")" << std::endl;
		return EXIT_FAILURE;
	}
	bparser::node& spriteroot = bparser::json::parse(*spritejson->GetDecompressionStream());
	spritejson->CloseDecompressionStream();
	if (spriteroot.size() != 1) {
		std::cout
			<< "Error: Empty " << ((sb3) ? "project.json" : "sprite.json") << "!" << std::endl;
		return EXIT_FAILURE;
	}
	bparser::node* spritetree = nullptr;
	if (sb3) {
		if (!spriteroot[0].exists("targets")) {
			std::cout
				<< "Error: Invalid sb3 file: project.json did not contain \"targets\"" << std::endl;
			return EXIT_FAILURE;
		}
		bparser::node& targets = spriteroot[0].find("targets");
		for (int i = 0; i < targets.size(); i++) {
			if (targets[i].find("name")[0].value == spritename) {
				spritetree = &targets[i];
				break;
			}
		}
		if (spritetree == nullptr) {
			std::cout
				<< "Error: project.json did not contain \"" << spritename << "\" sprite!" << std::endl
				<< "Valid Sprites:" << std::endl;
			for (int i = 0; i < targets.size(); i++) {
				std::cout
					<< "- \"" << targets[i].find("name")[0].value << "\"" << std::endl;
			}
			return EXIT_FAILURE;
		}
	}
	else spritetree = &spriteroot[0];
	bparser::node& sprite = *spritetree;

	// Check sprite.json structure
	if (
		!sprite.exists("isStage") ||
		!sprite.exists("name") ||
		!sprite.exists("variables") ||
		!sprite.exists("lists") ||
		!sprite.exists("broadcasts") ||
		!sprite.exists("blocks") ||
		!sprite.exists("comments") ||
		!sprite.exists("currentCostume") ||
		!sprite.exists("costumes") ||
		!sprite.exists("sounds") ||
		!sprite.exists("volume") ||
		!sprite.exists("visible") ||
		!sprite.exists("x") ||
		!sprite.exists("y") ||
		!sprite.exists("size") ||
		!sprite.exists("direction") ||
		!sprite.exists("draggable") ||
		!sprite.exists("rotationStyle")
	) {
		std::cout
			<< "Error: Invalid sprite.json structure! (Missing value)" << std::endl;
		return EXIT_FAILURE;
	}
	std::cout
		<< "Using Sprite: " << sprite.find("name")[0].value << std::endl;

	// Remove existing code, broadcasts, variables, and lists generated by lascra
	if (remove) {
		sprite.find("blocks").clear();
		sprite.find("variables").clear();
		sprite.find("lists").clear();
		sprite.find("broadcasts").clear();
	}
	else if (!keep) for (int i = 0; i < 4; i++) {
		bparser::node* section;
		if (i == 0) section = &sprite.find("blocks");
		else if (i == 1) section = &sprite.find("variables");
		else if (i == 2) section = &sprite.find("lists");
		else if (i == 3) section = &sprite.find("broadcasts");
		for (int e = 0; e < section->size(); e++) {
			if (id::test(section->at(e).value)) {
				section->erase(e);
				e--;
			}
		}
	}

	// Compile files
	if (files.size() == 0) {
		std::cout
			<< "Error: No code files!" << std::endl;
		return EXIT_FAILURE;
	}
	for (int i = 0; i < files.size(); i++) {
		std::string filename = files[i];
		std::cout
			<< "Compiling File: " << filename << std::endl;
		std::ifstream file(filename);
		if (!file.is_open()) {
			std::cout
				<< "Error: Failed to open file! (\"" << filename << "\" not found)" << std::endl;
			return EXIT_FAILURE;
		}
		bparser::node& code = bparser::sexpr::parse(file);
		file.close();
		try {
			compile(sprite, code);
		}
		catch (std::exception e) {
			std::cout << "Compile Error: " << filename << ":" << e.what() << std::endl;
			return EXIT_FAILURE;
		}
	}
	std::cout << "Compiled all files!" << std::endl;

	// Clear broadcast list if not Stage (Scratch broadcasts don't work otherwise)
	if (sprite.find("isStage")[0].value != "true")
		sprite.find("broadcasts").clear();
	// Set Name to "Stage" if isStage is true (Won't import otherwise)
	else
		sprite.find("name")[0].value = "Stage";

	// Update sprite.json
	std::cout << "Updating Sprite file... ";
	std::stringstream newjson;
	bparser::json::encode(spriteroot, newjson);
	if (display) std::cout << newjson.str() << std::endl;
	spritejson->SetCompressionStream(newjson);
	// Save updated file
	ZipFile::SaveAndClose(sprite3, sprite3filename);
	std::cout << "Done!" << std::endl;
	
	return EXIT_SUCCESS;
}
