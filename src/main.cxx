// lascra main file

#include <iostream>
#include <fstream>
#include <string>
#include <argh.h>
#include <ZipArchive.h>
#include <ZipFile.h>
#include <bparser/node.hxx>
#include <bparser/json.hxx>
#include <bparser/sexpr.hxx>

#include "compiler.hxx"
#include "id.hxx"

int main(int argc, char* argv[]) {
	// Command line parser
	argh::parser cmdl;
	cmdl.add_params({"-s", "--sprite"});
	cmdl.parse(argc, argv);
	// Help if no arguments or help flag
	if (!cmdl(1) || cmdl[{"-h", "--help"}]) {
		std::cout 
			<< "lascra (help)" << std::endl
			<< "Usage: lascra [sprite3 file] [code files...]" << std::endl
			<< "Parameters:" << std::endl
			<< "-s [sprite name], --sprite [sprite name]: Interpret sprite3 file as a sb3 file" << std::endl
			<< "   * Compiles for the provided sprite name" << std::endl
			<< "Flags:" << std::endl
			<< "-d, --display: Display generated sprite.json" << std::endl
			<< "-e, --erase: Erase all existing code in sprite" << std::endl
			<< "-k, --keep: Keep all existing code in sprite" << std::endl
			<< "  * including code previously generated by lascra" << std::endl;
		return EXIT_SUCCESS;
	}
	std::string spritename = "";
	if (!cmdl("s").str().empty()) spritename = cmdl("s").str();
	else if (!cmdl("sprite").str().empty()) spritename = cmdl("sprite").str();
	bool sb3 = (spritename == "") ? false : true;
	// Open sprite3 file
	ZipArchive::Ptr sprite3;
	std::string sprite3filename;
	if (cmdl(1)) {
		cmdl(1) >> sprite3filename;
		std::ifstream* sprite3file = new std::ifstream(sprite3filename, std::ios::binary);
		if (!sprite3file->is_open()) {
			std::cout
				<< "Error: Failed to open " << ((cmdl("sprite").str().empty()) ? "sprite3" : "sb3") << " file! (\"" << sprite3filename << "\" not found)" << std::endl;
			return EXIT_FAILURE;
		}
		sprite3 = ZipArchive::Create(sprite3file, true);
		if (sprite3 == nullptr) {
			std::cout
				<< "Error: Invalid zip archive (Processing failed)" << std::endl;
			return EXIT_FAILURE;
		}
	}
	// Open sprite.json
	ZipArchiveEntry::Ptr spritejson = (sb3) ? sprite3->GetEntry("project.json") : sprite3->GetEntry("sprite.json");
	if (spritejson == nullptr) {
		std::cout
			<< "Error: Invalid " << ((sb3) ? "sb3": "sprite3") << " file! (Missing " << ((sb3) ? "\"project.json\"" : "\"sprite.json\"") << ")" << std::endl;
		return EXIT_FAILURE;
	}
	bparser::node& spriteroot = bparser::json::parse(*spritejson->GetDecompressionStream());
	spritejson->CloseDecompressionStream();
	if (spriteroot.size() != 1) {
		std::cout
			<< "Error: Empty " << ((sb3) ? "project.json" : "sprite.json") << "!" << std::endl;
		return EXIT_FAILURE;
	}
	bparser::node* spritetree = nullptr;
	if (sb3) {
		if (!spriteroot[0].exists("targets")) {
			std::cout
				<< "Error: Invalid sb3 file: project.json did not contain \"targets\"" << std::endl;
			return EXIT_FAILURE;
		}
		bparser::node& targets = spriteroot[0].find("targets");
		for (int i = 0; i < targets.size(); i++) {
			if (targets[i].find("name")[0].value == spritename) {
				spritetree = &targets[i];
				break;
			}
		}
		if (spritetree == nullptr) {
			std::cout
				<< "Error: project.json did not contain \"" << spritename << "\" sprite!" << std::endl
				<< "Valid Sprites:" << std::endl;
			for (int i = 0; i < targets.size(); i++) {
				std::cout
					<< "- \"" << targets[i].find("name")[0].value << "\"" << std::endl;
			}
			return EXIT_FAILURE;
		}
	}
	else spritetree = &spriteroot[0];
	bparser::node& sprite = *spritetree;

	// Check sprite.json structure
	if (
		!sprite.exists("isStage") ||
		!sprite.exists("name") ||
		!sprite.exists("variables") ||
		!sprite.exists("lists") ||
		!sprite.exists("broadcasts") ||
		!sprite.exists("blocks") ||
		!sprite.exists("comments") ||
		!sprite.exists("currentCostume") ||
		!sprite.exists("costumes") ||
		!sprite.exists("sounds") ||
		!sprite.exists("volume") ||
		!sprite.exists("visible") ||
		!sprite.exists("x") ||
		!sprite.exists("y") ||
		!sprite.exists("size") ||
		!sprite.exists("direction") ||
		!sprite.exists("draggable") ||
		!sprite.exists("rotationStyle")
	) {
		std::cout
			<< "Error: Invalid sprite.json structure! (Missing value)" << std::endl;
		return EXIT_FAILURE;
	}
	std::cout
		<< "Using Sprite: " << sprite.find("name")[0].value << std::endl;

	// Remove existing code, broadcasts, variables, and lists generated by lascra
	if (cmdl[{"-r","--remove"}]) {
		sprite.find("blocks").clear();
		sprite.find("variables").clear();
		sprite.find("lists").clear();
		sprite.find("broadcasts").clear();
	}
	else if (!cmdl[{"-k","--keep"}]) for (int i = 0; i < 4; i++) {
		bparser::node* section;
		if (i == 0) section = &sprite.find("blocks");
		else if (i == 1) section = &sprite.find("variables");
		else if (i == 2) section = &sprite.find("lists");
		else if (i == 3) section = &sprite.find("broadcasts");
		for (int e = 0; e < section->size(); e++) {
			if (id::test(section->at(e).value)) {
				section->erase(e);
				e--;
			}
		}
	}

	// Compile files
	if (cmdl.size() <= 2) {
		std::cout
			<< "Error: No code files!" << std::endl;
		return EXIT_FAILURE;
	}
	for (int i = 2; i < cmdl.size(); i++) {
		std::string filename;
		cmdl(i) >> filename;
		std::cout
			<< "Compiling File: " << filename << std::endl;
		std::ifstream file(filename);
		if (!file.is_open()) {
			std::cout
				<< "Error: Failed to open file! (\"" << filename << "\" not found)" << std::endl;
			return EXIT_FAILURE;
		}
		bparser::node& code = bparser::sexpr::parse(file);
		file.close();
		try {
			compile(sprite, code);
		}
		catch (std::exception e) {
			std::cout << "Compile Error: " << filename << ":" << e.what() << std::endl;
			return EXIT_FAILURE;
		}
	}
	std::cout << "Compiled all files!" << std::endl;

	// Clear broadcast list if not Stage (Scratch broadcasts don't work otherwise)
	if (sprite.find("isStage")[0].value != "true")
		sprite.find("broadcasts").clear();
	// Set Name to "Stage" if isStage is true (Won't import otherwise)
	else
		sprite.find("name")[0].value = "Stage";

	// Update sprite.json
	std::cout << "Updating Sprite file... ";
	std::stringstream newjson;
	bparser::json::encode(spriteroot, newjson);
	if (cmdl[{"-d", "--display"}]) std::cout << newjson.str() << std::endl;
	spritejson->SetCompressionStream(newjson);
	// Save updated file
	ZipFile::SaveAndClose(sprite3, sprite3filename);
	std::cout << "Done!" << std::endl;
	
	return EXIT_SUCCESS;
}
